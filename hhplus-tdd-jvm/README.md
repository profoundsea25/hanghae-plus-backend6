# 동시성 제어 방식에 대한 분석

- 항해 플러스 백엔드 6기 양해준

### 결론

- 사용한 방법은 모든 충전/사용 저장 요청에 대해 동기화하되, 구현체로 ReentrantLock을 선택하였습니다. (글로벌 락)

### 현상 분석

- 저장에 필요한 연산은 `1) 조회 2) 포인트 연산 3) 내역 저장`
- 문제가 되는 부분은 내역을 저장하는 부분 (`PointHistoryTable`)
    - thread-safe하지 않은 MutableList로 데이터를 저장하고 있어, 동시 다발적으로 add 연산이 들어올 경우, 데이터 유실 발생
- 동시성 제어 포인트
    - 동일 유저를 포함해 다양한 유저가 동시에 포인트 충전/사용을 했을 때 thread-safe하지 않은 저장 부분을 동시성 이슈로부터 보호해야 함

### 고려한 선택지

1. `synchronized` 메서드 혹은 `@Synchronized` (Kotlin 제공)
    - 가장 간단하지만 가장 느린 방법
    - 뮤텍스 방식으로, 특정 Lock 객체를 기반으로 동시에 하나의 스레드만 접근 가능
2. `ReentrantLock` (Java 제공)
    - synchronized와 비슷하지만, 추가적인 옵션이 있음.
    - tryLock()을 통해 Lock을 획득에 대한 timeout을 지정할 수 있음.
        - 이를 활용하여, Lock 점유한 쪽에서 블로킹을 오래할 경우, 대기하는 쪽에서 빠르게 실패(fast fail)할 수 있음.
        - 이는 응답성을 높이고 blocking된 스레드 시간을 줄일 수 있음을 의미.
3. 미들웨어 사용 (Redis, DB)
    - 일례로 JVM Redis 라이브러리 중, Redisson에서 제공하는 tryLock은 lease time을 설정할 수 있음.
        - 일정 시간이 지나면 Lock의 소유권을 회수함.
        - 이는 Lock을 점유하는 쪽에서 너무 오래 걸리거나, unlock이 호출되지 않아 데드락이 발생하는 경우를 방지함.
    - MySQL 등의 RDBMS를 통한 비관적 락
4. (Message) Queue
    - 충전/사용 요청이 발생하면 이를 메시지 큐로 이벤트 발행
    - 발행된 이벤트는 메시지 큐에서 보관되다가, 컨슈머 애플리케이션에서 순차적으로 처리
    - 인프라 구성의 난이도가 있음

### 결론의 이유

1. 가장 간단한 쉽고 구현
    - 코드를 읽고 수정하는 쪽에서도 난이도가 높지 않음을 의미
2. synchronized 보다 더 많은 옵션 (tryLock의 timeout 등)
3. 다른 외부 의존성이 필요하지 않음

### 결론의 문제점

- lease time(락 점유권 회수 타임아웃) 설정이 없어, lock 이후 unlock 메서드 호출이 안 된다면 데드락에 빠질 위험이 있습니다.

### 생각한 최적의 대안

- 구현의 난이도, pub/sub 구조의 자원 효율성, 레퍼런스 등을 생각해봤을 때, Redis(+ 구현체 Redisson)을 사용했을 것 같습니다.

### 검증 방법

- 동일 유저에 대해서 포인트 충전/사용을 동시에 요청 시, 포인트 결과값과 이용 내역이 정확히 남는지 확인
- 다양한 유저의 포인트 충전 동시 요청 시, 각각의 사용자에게 알맞은 값과 이력이 남는지 확인
